// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: timedmetadata.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const clearAssetTimedMetadata = `-- name: ClearAssetTimedMetadata :exec
DELETE FROM timedmetadata WHERE asset_id = $1
`

func (q *Queries) ClearAssetTimedMetadata(ctx context.Context, assetID null_v4.Int) error {
	_, err := q.db.ExecContext(ctx, clearAssetTimedMetadata, assetID)
	return err
}

const clearEpisodeTimedMetadata = `-- name: ClearEpisodeTimedMetadata :exec
DELETE FROM timedmetadata WHERE episode_id = $1
`

func (q *Queries) ClearEpisodeTimedMetadata(ctx context.Context, episodeID null_v4.Int) error {
	_, err := q.db.ExecContext(ctx, clearEpisodeTimedMetadata, episodeID)
	return err
}

const clearMediaItemTimedMetadata = `-- name: ClearMediaItemTimedMetadata :exec
DELETE FROM timedmetadata WHERE mediaitem_id = $1::uuid
`

func (q *Queries) ClearMediaItemTimedMetadata(ctx context.Context, mediaitemID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearMediaItemTimedMetadata, mediaitemID)
	return err
}

const getAssetTimedMetadata = `-- name: GetAssetTimedMetadata :many
SELECT t.id,
       status,
       user_created,
       date_created,
       user_updated,
       date_updated,
       label,
       type,
       highlight,
       title,
       asset_id,
       seconds,
       description,
       episode_id,
       mediaitem_id,
       content_type,
       song_id,
       (SELECT array_agg(p.persons_id) FROM "timedmetadata_persons" p WHERE p.timedmetadata_id = t.id)::uuid[]  AS person_ids
FROM timedmetadata t
WHERE asset_id = $1
ORDER BY seconds
`

type GetAssetTimedMetadataRow struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	Status      string         `db:"status" json:"status"`
	UserCreated uuid.NullUUID  `db:"user_created" json:"userCreated"`
	DateCreated null_v4.Time   `db:"date_created" json:"dateCreated"`
	UserUpdated uuid.NullUUID  `db:"user_updated" json:"userUpdated"`
	DateUpdated null_v4.Time   `db:"date_updated" json:"dateUpdated"`
	Label       string         `db:"label" json:"label"`
	Type        string         `db:"type" json:"type"`
	Highlight   bool           `db:"highlight" json:"highlight"`
	Title       null_v4.String `db:"title" json:"title"`
	AssetID     null_v4.Int    `db:"asset_id" json:"assetId"`
	Seconds     float32        `db:"seconds" json:"seconds"`
	Description null_v4.String `db:"description" json:"description"`
	EpisodeID   null_v4.Int    `db:"episode_id" json:"episodeId"`
	MediaitemID uuid.NullUUID  `db:"mediaitem_id" json:"mediaitemId"`
	ContentType null_v4.String `db:"content_type" json:"contentType"`
	SongID      uuid.NullUUID  `db:"song_id" json:"songId"`
	PersonIds   []uuid.UUID    `db:"person_ids" json:"personIds"`
}

func (q *Queries) GetAssetTimedMetadata(ctx context.Context, assetID null_v4.Int) ([]GetAssetTimedMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssetTimedMetadata, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetTimedMetadataRow
	for rows.Next() {
		var i GetAssetTimedMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.UserCreated,
			&i.DateCreated,
			&i.UserUpdated,
			&i.DateUpdated,
			&i.Label,
			&i.Type,
			&i.Highlight,
			&i.Title,
			&i.AssetID,
			&i.Seconds,
			&i.Description,
			&i.EpisodeID,
			&i.MediaitemID,
			&i.ContentType,
			&i.SongID,
			pq.Array(&i.PersonIds),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTimedMetadata = `-- name: InsertTimedMetadata :one
INSERT INTO timedmetadata (
  id,
  status,
  date_created,
  date_updated,
  label,
  type,
  highlight,
  title,
  asset_id,
  seconds,
  description,
  episode_id,
  mediaitem_id,
  content_type,
  song_id
)
VALUES (
  gen_random_uuid(),
  $1,
  NOW(),
  NOW(),
  $2,
  $3,
  $4,
  $5::varchar,
  $6,
  $7::real,
  $8::varchar,
  $9,
  $10,
  $11,
  $12
)
RETURNING id
`

type InsertTimedMetadataParams struct {
	Status      string         `db:"status" json:"status"`
	Label       string         `db:"label" json:"label"`
	Type        string         `db:"type" json:"type"`
	Highlight   bool           `db:"highlight" json:"highlight"`
	Title       string         `db:"title" json:"title"`
	AssetID     null_v4.Int    `db:"asset_id" json:"assetId"`
	Seconds     float32        `db:"seconds" json:"seconds"`
	Description string         `db:"description" json:"description"`
	EpisodeID   null_v4.Int    `db:"episode_id" json:"episodeId"`
	MediaitemID uuid.NullUUID  `db:"mediaitem_id" json:"mediaitemId"`
	ContentType null_v4.String `db:"content_type" json:"contentType"`
	SongID      uuid.NullUUID  `db:"song_id" json:"songId"`
}

func (q *Queries) InsertTimedMetadata(ctx context.Context, arg InsertTimedMetadataParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertTimedMetadata,
		arg.Status,
		arg.Label,
		arg.Type,
		arg.Highlight,
		arg.Title,
		arg.AssetID,
		arg.Seconds,
		arg.Description,
		arg.EpisodeID,
		arg.MediaitemID,
		arg.ContentType,
		arg.SongID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getTimedMetadata = `-- name: getTimedMetadata :many
SELECT tm.id,
       tm.type,
       tm.content_type,
       tm.song_id,
       (SELECT array_agg(c.person_id) FROM "contributions" c WHERE c.timedmetadata_id = tm.id)::uuid[] AS person_ids,
       tm.title                                                  AS original_title,
       tm.description                                            AS original_description,
       COALESCE((SELECT json_object_agg(ts.languages_code, ts.title)
                 FROM timedmetadata_translations ts
                 WHERE ts.timedmetadata_id = tm.id), '{}')::json AS title,
       COALESCE((SELECT json_object_agg(ts.languages_code, ts.description)
                 FROM timedmetadata_translations ts
                 WHERE ts.timedmetadata_id = tm.id), '{}')::json AS description,
       tm.seconds,
       tm.highlight,
       tm.mediaitem_id,
       COALESCE(images.images, '{}'::json)            AS images,
       COALESCE((
          -- if there is a next timedmetadata, calculate the duration between the current and the next timedmetadata
          SELECT nextTm.seconds - tm.seconds
          FROM timedmetadata nextTm
          WHERE (nextTm.mediaitem_id = tm.mediaitem_id OR nextTm.asset_id = tm.asset_id)
          AND nextTm.seconds > tm.seconds
          ORDER BY nextTm.seconds
          LIMIT 1
        ), (
          -- if there is no next timedmetadata, calculate the duration of the asset
          SELECT asset.duration - tm.seconds
          FROM assets asset
          WHERE asset.id = tm.asset_id
          OR asset.id = mi.asset_id
          LIMIT 1
        ), 0)::float as duration
FROM timedmetadata tm
LEFT JOIN mediaitems mi ON (mi.id = tm.mediaitem_id)
LEFT JOIN (
    SELECT
    simg.timedmetadata_id,
    json_agg(json_build_object('style', img.style, 'language', img.language, 'filename_disk', df.filename_disk)) AS images
    FROM timedmetadata_styledimages simg
    JOIN styledimages img ON (img.id = simg.styledimages_id)
    JOIN directus_files df ON (img.file = df.id)
    WHERE simg.timedmetadata_id = ANY($1::uuid[])
    GROUP BY simg.timedmetadata_id
) images ON (images.timedmetadata_id = tm.id)
WHERE tm.id = ANY ($1::uuid[])
`

type getTimedMetadataRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	Type                string          `db:"type" json:"type"`
	ContentType         null_v4.String  `db:"content_type" json:"contentType"`
	SongID              uuid.NullUUID   `db:"song_id" json:"songId"`
	PersonIds           []uuid.UUID     `db:"person_ids" json:"personIds"`
	OriginalTitle       null_v4.String  `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Seconds             float32         `db:"seconds" json:"seconds"`
	Highlight           bool            `db:"highlight" json:"highlight"`
	MediaitemID         uuid.NullUUID   `db:"mediaitem_id" json:"mediaitemId"`
	Images              json.RawMessage `db:"images" json:"images"`
	Duration            float64         `db:"duration" json:"duration"`
}

func (q *Queries) getTimedMetadata(ctx context.Context, ids []uuid.UUID) ([]getTimedMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimedMetadata, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getTimedMetadataRow
	for rows.Next() {
		var i getTimedMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ContentType,
			&i.SongID,
			pq.Array(&i.PersonIds),
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Seconds,
			&i.Highlight,
			&i.MediaitemID,
			&i.Images,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
