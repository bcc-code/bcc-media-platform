// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: timedmetadata.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const getTimedMetadata = `-- name: getTimedMetadata :many
SELECT md.id,
       md.type,
       md.chapter_type,
       md.song_id,
       md.person_id,
       md.title                                                  AS original_title,
       md.description                                            AS original_description,
       COALESCE((SELECT json_object_agg(ts.languages_code, ts.title)
                 FROM timedmetadata_translations ts
                 WHERE ts.timedmetadata_id = md.id), '{}')::json AS title,
       COALESCE((SELECT json_object_agg(ts.languages_code, ts.description)
                 FROM timedmetadata_translations ts
                 WHERE ts.timedmetadata_id = md.id), '{}')::json AS description,
       md.timestamp,
       md.highlight
FROM timedmetadata md
WHERE md.id = ANY ($1::uuid[])
`

type getTimedMetadataRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	Type                string          `db:"type" json:"type"`
	ChapterType         null_v4.String  `db:"chapter_type" json:"chapterType"`
	SongID              uuid.NullUUID   `db:"song_id" json:"songId"`
	PersonID            uuid.NullUUID   `db:"person_id" json:"personId"`
	OriginalTitle       null_v4.String  `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Timestamp           time.Time       `db:"timestamp" json:"timestamp"`
	Highlight           bool            `db:"highlight" json:"highlight"`
}

func (q *Queries) getTimedMetadata(ctx context.Context, ids []uuid.UUID) ([]getTimedMetadataRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimedMetadata, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getTimedMetadataRow
	for rows.Next() {
		var i getTimedMetadataRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ChapterType,
			&i.SongID,
			&i.PersonID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Timestamp,
			&i.Highlight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
