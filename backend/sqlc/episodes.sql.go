// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: episodes.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/tabbed/pqtype"
	null_v4 "gopkg.in/guregu/null.v4"
)

const getEpisode = `-- name: GetEpisode :one
SELECT agerating_code, asset_id, available_from, available_to, date_created, date_updated, episode_number, id, image_file_id, legacy_description_id, legacy_extra_description_id, legacy_id, legacy_program_id, legacy_tags_id, legacy_title_id, migration_data, publish_date, season_id, status, type, user_created, user_updated FROM public.episodes WHERE id = $1
`

func (q *Queries) GetEpisode(ctx context.Context, id int32) (Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, id)
	var i Episode
	err := row.Scan(
		&i.AgeratingCode,
		&i.AssetID,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.DateCreated,
		&i.DateUpdated,
		&i.EpisodeNumber,
		&i.ID,
		&i.ImageFileID,
		&i.LegacyDescriptionID,
		&i.LegacyExtraDescriptionID,
		&i.LegacyID,
		&i.LegacyProgramID,
		&i.LegacyTagsID,
		&i.LegacyTitleID,
		&i.MigrationData,
		&i.PublishDate,
		&i.SeasonID,
		&i.Status,
		&i.Type,
		&i.UserCreated,
		&i.UserUpdated,
	)
	return i, err
}

const getEpisodeRoles = `-- name: GetEpisodeRoles :many
SELECT episodes_id, id, type, usergroups_code, date_created, date_updated FROM public.episodes_usergroups
`

func (q *Queries) GetEpisodeRoles(ctx context.Context) ([]EpisodesUsergroup, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EpisodesUsergroup
	for rows.Next() {
		var i EpisodesUsergroup
		if err := rows.Scan(
			&i.EpisodesID,
			&i.ID,
			&i.Type,
			&i.UsergroupsCode,
			&i.DateCreated,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodeTranslations = `-- name: GetEpisodeTranslations :many
SELECT description, episodes_id, extra_description, id, is_primary, languages_code, title FROM public.episodes_translations
`

func (q *Queries) GetEpisodeTranslations(ctx context.Context) ([]EpisodesTranslation, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeTranslations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EpisodesTranslation
	for rows.Next() {
		var i EpisodesTranslation
		if err := rows.Scan(
			&i.Description,
			&i.EpisodesID,
			&i.ExtraDescription,
			&i.ID,
			&i.IsPrimary,
			&i.LanguagesCode,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodes = `-- name: GetEpisodes :many
SELECT agerating_code, asset_id, available_from, available_to, date_created, date_updated, episode_number, id, image_file_id, legacy_description_id, legacy_extra_description_id, legacy_id, legacy_program_id, legacy_tags_id, legacy_title_id, migration_data, publish_date, season_id, status, type, user_created, user_updated FROM public.episodes
`

func (q *Queries) GetEpisodes(ctx context.Context) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.AgeratingCode,
			&i.AssetID,
			&i.AvailableFrom,
			&i.AvailableTo,
			&i.DateCreated,
			&i.DateUpdated,
			&i.EpisodeNumber,
			&i.ID,
			&i.ImageFileID,
			&i.LegacyDescriptionID,
			&i.LegacyExtraDescriptionID,
			&i.LegacyID,
			&i.LegacyProgramID,
			&i.LegacyTagsID,
			&i.LegacyTitleID,
			&i.MigrationData,
			&i.PublishDate,
			&i.SeasonID,
			&i.Status,
			&i.Type,
			&i.UserCreated,
			&i.UserUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodesWithTranslationsByID = `-- name: GetEpisodesWithTranslationsByID :many
WITH t AS (SELECT
	t.episodes_id,
	json_object_agg(t.languages_code, t.title) as title,
	json_object_agg(t.languages_code, t.description) as description,
	json_object_agg(t.languages_code, t.extra_description) as extra_description
FROM episodes_translations t
WHERE t.episodes_id = ANY($1::int[])
GROUP BY episodes_id)
SELECT
	e.id, e.asset_id, e.episode_number, e.image_file_id, e.season_id, e.type,
	t.title, t.description, t.extra_description,
	ea.published::bool published,
	ea.available_from::timestamptz available_from, ea.available_to::timestamptz available_to,
	ea.usergroups::text[] usergroups, ea.usergroups_downloads::text[] download_groups, ea.usergroups_earlyaccess::text[] early_access_groups
 FROM episodes e
JOIN t ON e.id = t.episodes_id
JOIN episodes_access ea on ea.id = e.id
`

type GetEpisodesWithTranslationsByIDRow struct {
	ID                int32           `db:"id" json:"id"`
	AssetID           null_v4.Int     `db:"asset_id" json:"assetID"`
	EpisodeNumber     null_v4.Int     `db:"episode_number" json:"episodeNumber"`
	ImageFileID       uuid.NullUUID   `db:"image_file_id" json:"imageFileID"`
	SeasonID          null_v4.Int     `db:"season_id" json:"seasonID"`
	Type              string          `db:"type" json:"type"`
	Title             json.RawMessage `db:"title" json:"title"`
	Description       json.RawMessage `db:"description" json:"description"`
	ExtraDescription  json.RawMessage `db:"extra_description" json:"extraDescription"`
	Published         bool            `db:"published" json:"published"`
	AvailableFrom     time.Time       `db:"available_from" json:"availableFrom"`
	AvailableTo       time.Time       `db:"available_to" json:"availableTo"`
	Usergroups        []string        `db:"usergroups" json:"usergroups"`
	DownloadGroups    []string        `db:"download_groups" json:"downloadGroups"`
	EarlyAccessGroups []string        `db:"early_access_groups" json:"earlyAccessGroups"`
}

func (q *Queries) GetEpisodesWithTranslationsByID(ctx context.Context, dollar_1 []int32) ([]GetEpisodesWithTranslationsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodesWithTranslationsByID, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEpisodesWithTranslationsByIDRow
	for rows.Next() {
		var i GetEpisodesWithTranslationsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.AssetID,
			&i.EpisodeNumber,
			&i.ImageFileID,
			&i.SeasonID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.ExtraDescription,
			&i.Published,
			&i.AvailableFrom,
			&i.AvailableTo,
			pq.Array(&i.Usergroups),
			pq.Array(&i.DownloadGroups),
			pq.Array(&i.EarlyAccessGroups),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesForEpisodes = `-- name: GetFilesForEpisodes :many
SELECT e.id AS episodes_id, f.asset_id, f.audio_language_id, f.date_created, f.date_updated, f.extra_metadata, f.id, f.mime_type, f.path, f.storage, f.subtitle_language_id, f.type, f.user_created, f.user_updated FROM episodes e
JOIN assets a ON e.asset_id = a.id
JOIN assetfiles f ON a.id = f.asset_id
WHERE e.id = ANY($1::int[])
`

type GetFilesForEpisodesRow struct {
	EpisodesID         int32                 `db:"episodes_id" json:"episodesID"`
	AssetID            int32                 `db:"asset_id" json:"assetID"`
	AudioLanguageID    null_v4.String        `db:"audio_language_id" json:"audioLanguageID"`
	DateCreated        time.Time             `db:"date_created" json:"dateCreated"`
	DateUpdated        time.Time             `db:"date_updated" json:"dateUpdated"`
	ExtraMetadata      pqtype.NullRawMessage `db:"extra_metadata" json:"extraMetadata"`
	ID                 int32                 `db:"id" json:"id"`
	MimeType           string                `db:"mime_type" json:"mimeType"`
	Path               string                `db:"path" json:"path"`
	Storage            string                `db:"storage" json:"storage"`
	SubtitleLanguageID null_v4.String        `db:"subtitle_language_id" json:"subtitleLanguageID"`
	Type               string                `db:"type" json:"type"`
	UserCreated        uuid.NullUUID         `db:"user_created" json:"userCreated"`
	UserUpdated        uuid.NullUUID         `db:"user_updated" json:"userUpdated"`
}

func (q *Queries) GetFilesForEpisodes(ctx context.Context, dollar_1 []int32) ([]GetFilesForEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesForEpisodes, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesForEpisodesRow
	for rows.Next() {
		var i GetFilesForEpisodesRow
		if err := rows.Scan(
			&i.EpisodesID,
			&i.AssetID,
			&i.AudioLanguageID,
			&i.DateCreated,
			&i.DateUpdated,
			&i.ExtraMetadata,
			&i.ID,
			&i.MimeType,
			&i.Path,
			&i.Storage,
			&i.SubtitleLanguageID,
			&i.Type,
			&i.UserCreated,
			&i.UserUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesForEpisode = `-- name: GetRolesForEpisode :many
SELECT usergroups_code FROM public.episodes_usergroups WHERE episodes_id = $1
`

func (q *Queries) GetRolesForEpisode(ctx context.Context, episodesID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRolesForEpisode, episodesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var usergroups_code string
		if err := rows.Scan(&usergroups_code); err != nil {
			return nil, err
		}
		items = append(items, usergroups_code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreamsForEpisodes = `-- name: GetStreamsForEpisodes :many
WITH audiolang AS (SELECT s.id, array_agg(al.languages_code) langs FROM episodes e
	JOIN assets a ON e.asset_id = a.id
	LEFT JOIN assetstreams s ON a.id = s.asset_id
	LEFT JOIN assetstreams_audio_languages al ON al.assetstreams_id = s.id
	WHERE e.id = 1
	GROUP BY s.id),
sublang AS (SELECT s.id, array_agg(al.languages_code) langs FROM episodes e
	JOIN assets a ON e.asset_id = a.id
	LEFT JOIN assetstreams s ON a.id = s.asset_id
	LEFT JOIN assetstreams_subtitle_languages al ON al.assetstreams_id = s.id
	WHERE e.id = 1
	GROUP BY s.id)
SELECT e.id AS episodes_id, s.asset_id, s.date_created, s.date_updated, s.encryption_key_id, s.extra_metadata, s.id, s.legacy_videourl_id, s.path, s.service, s.status, s.type, s.url, s.user_created, s.user_updated, al.langs::text[] audio_languages, sl.langs::text[] subtitle_languages FROM episodes e
JOIN assets a ON e.asset_id = a.id
JOIN assetstreams s ON a.id = s.asset_id
LEFT JOIN audiolang al ON al.id = s.id
LEFT JOIN sublang sl ON sl.id = s.id
WHERE e.id = ANY($1::int[])
`

type GetStreamsForEpisodesRow struct {
	EpisodesID        int32                 `db:"episodes_id" json:"episodesID"`
	AssetID           int32                 `db:"asset_id" json:"assetID"`
	DateCreated       time.Time             `db:"date_created" json:"dateCreated"`
	DateUpdated       time.Time             `db:"date_updated" json:"dateUpdated"`
	EncryptionKeyID   null_v4.String        `db:"encryption_key_id" json:"encryptionKeyID"`
	ExtraMetadata     pqtype.NullRawMessage `db:"extra_metadata" json:"extraMetadata"`
	ID                int32                 `db:"id" json:"id"`
	LegacyVideourlID  null_v4.Int           `db:"legacy_videourl_id" json:"legacyVideourlID"`
	Path              string                `db:"path" json:"path"`
	Service           string                `db:"service" json:"service"`
	Status            string                `db:"status" json:"status"`
	Type              string                `db:"type" json:"type"`
	Url               string                `db:"url" json:"url"`
	UserCreated       uuid.NullUUID         `db:"user_created" json:"userCreated"`
	UserUpdated       uuid.NullUUID         `db:"user_updated" json:"userUpdated"`
	AudioLanguages    []string              `db:"audio_languages" json:"audioLanguages"`
	SubtitleLanguages []string              `db:"subtitle_languages" json:"subtitleLanguages"`
}

func (q *Queries) GetStreamsForEpisodes(ctx context.Context, dollar_1 []int32) ([]GetStreamsForEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStreamsForEpisodes, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreamsForEpisodesRow
	for rows.Next() {
		var i GetStreamsForEpisodesRow
		if err := rows.Scan(
			&i.EpisodesID,
			&i.AssetID,
			&i.DateCreated,
			&i.DateUpdated,
			&i.EncryptionKeyID,
			&i.ExtraMetadata,
			&i.ID,
			&i.LegacyVideourlID,
			&i.Path,
			&i.Service,
			&i.Status,
			&i.Type,
			&i.Url,
			&i.UserCreated,
			&i.UserUpdated,
			pq.Array(&i.AudioLanguages),
			pq.Array(&i.SubtitleLanguages),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsForEpisode = `-- name: GetTranslationsForEpisode :many
SELECT description, episodes_id, extra_description, id, is_primary, languages_code, title FROM public.episodes_translations WHERE episodes_id = $1
`

func (q *Queries) GetTranslationsForEpisode(ctx context.Context, episodesID int32) ([]EpisodesTranslation, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationsForEpisode, episodesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EpisodesTranslation
	for rows.Next() {
		var i EpisodesTranslation
		if err := rows.Scan(
			&i.Description,
			&i.EpisodesID,
			&i.ExtraDescription,
			&i.ID,
			&i.IsPrimary,
			&i.LanguagesCode,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVisibilityForEpisode = `-- name: GetVisibilityForEpisode :one
SELECT id, status, publish_date, available_from, available_to, season_id FROM public.episodes WHERE id = $1
`

type GetVisibilityForEpisodeRow struct {
	ID            int32        `db:"id" json:"id"`
	Status        string       `db:"status" json:"status"`
	PublishDate   time.Time    `db:"publish_date" json:"publishDate"`
	AvailableFrom null_v4.Time `db:"available_from" json:"availableFrom"`
	AvailableTo   null_v4.Time `db:"available_to" json:"availableTo"`
	SeasonID      null_v4.Int  `db:"season_id" json:"seasonID"`
}

func (q *Queries) GetVisibilityForEpisode(ctx context.Context, id int32) (GetVisibilityForEpisodeRow, error) {
	row := q.db.QueryRowContext(ctx, getVisibilityForEpisode, id)
	var i GetVisibilityForEpisodeRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.PublishDate,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.SeasonID,
	)
	return i, err
}

const getVisibilityForEpisodes = `-- name: GetVisibilityForEpisodes :many
SELECT id, status, publish_date, available_from, available_to, season_id FROM public.episodes
`

type GetVisibilityForEpisodesRow struct {
	ID            int32        `db:"id" json:"id"`
	Status        string       `db:"status" json:"status"`
	PublishDate   time.Time    `db:"publish_date" json:"publishDate"`
	AvailableFrom null_v4.Time `db:"available_from" json:"availableFrom"`
	AvailableTo   null_v4.Time `db:"available_to" json:"availableTo"`
	SeasonID      null_v4.Int  `db:"season_id" json:"seasonID"`
}

func (q *Queries) GetVisibilityForEpisodes(ctx context.Context) ([]GetVisibilityForEpisodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getVisibilityForEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVisibilityForEpisodesRow
	for rows.Next() {
		var i GetVisibilityForEpisodesRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.PublishDate,
			&i.AvailableFrom,
			&i.AvailableTo,
			&i.SeasonID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshAccessView = `-- name: RefreshAccessView :one
SELECT update_episodes_access()
`

func (q *Queries) RefreshAccessView(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, refreshAccessView)
	var update_episodes_access bool
	err := row.Scan(&update_episodes_access)
	return update_episodes_access, err
}
