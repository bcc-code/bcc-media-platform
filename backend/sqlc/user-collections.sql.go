// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: user-collections.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/tabbed/pqtype"
)

const getUserCollectionEntries = `-- name: getUserCollectionEntries :many
SELECT ce.id, ce.collection_id, ce.updated_at, ce.created_at, ce.sort, ce.type, ce.item_id
FROM users.collectionentries ce
WHERE ce.id = ANY ($1::uuid[])
`

type getUserCollectionEntriesRow struct {
	ID           uuid.UUID `db:"id" json:"id"`
	CollectionID uuid.UUID `db:"collection_id" json:"collectionID"`
	UpdatedAt    time.Time `db:"updated_at" json:"updatedAt"`
	CreatedAt    time.Time `db:"created_at" json:"createdAt"`
	Sort         int32     `db:"sort" json:"sort"`
	Type         string    `db:"type" json:"type"`
	ItemID       uuid.UUID `db:"item_id" json:"itemID"`
}

func (q *Queries) getUserCollectionEntries(ctx context.Context, ids []uuid.UUID) ([]getUserCollectionEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionEntries, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionEntriesRow
	for rows.Next() {
		var i getUserCollectionEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Sort,
			&i.Type,
			&i.ItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectionEntryIDsForUserCollectionIDs = `-- name: getUserCollectionEntryIDsForUserCollectionIDs :many
SELECT ce.id, ce.collection_id AS parent_id
FROM users.collectionentries ce
WHERE ce.collection_id = ANY ($1::uuid[])
`

type getUserCollectionEntryIDsForUserCollectionIDsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentID"`
}

func (q *Queries) getUserCollectionEntryIDsForUserCollectionIDs(ctx context.Context, collectionIds []uuid.UUID) ([]getUserCollectionEntryIDsForUserCollectionIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionEntryIDsForUserCollectionIDs, pq.Array(collectionIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionEntryIDsForUserCollectionIDsRow
	for rows.Next() {
		var i getUserCollectionEntryIDsForUserCollectionIDsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectionIDsForProfileIDs = `-- name: getUserCollectionIDsForProfileIDs :many
SELECT c.id, c.profile_id AS parent_id
FROM users.collections c
WHERE c.profile_id = ANY ($1::uuid[])
`

type getUserCollectionIDsForProfileIDsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentID"`
}

func (q *Queries) getUserCollectionIDsForProfileIDs(ctx context.Context, profileIds []uuid.UUID) ([]getUserCollectionIDsForProfileIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionIDsForProfileIDs, pq.Array(profileIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionIDsForProfileIDsRow
	for rows.Next() {
		var i getUserCollectionIDsForProfileIDsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollections = `-- name: getUserCollections :many
SELECT c.id, c.profile_id, c.updated_at, c.created_at, c.title, c.metadata
FROM users.collections c
WHERE id = ANY ($1::uuid[])
`

type getUserCollectionsRow struct {
	ID        uuid.UUID             `db:"id" json:"id"`
	ProfileID uuid.UUID             `db:"profile_id" json:"profileID"`
	UpdatedAt time.Time             `db:"updated_at" json:"updatedAt"`
	CreatedAt time.Time             `db:"created_at" json:"createdAt"`
	Title     string                `db:"title" json:"title"`
	Metadata  pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) getUserCollections(ctx context.Context, ids []uuid.UUID) ([]getUserCollectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollections, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionsRow
	for rows.Next() {
		var i getUserCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Title,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
