// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: user-collections.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const deleteUserCollectionEntry = `-- name: DeleteUserCollectionEntry :exec
DELETE
FROM users.collectionentries
WHERE id = $1
`

func (q *Queries) DeleteUserCollectionEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserCollectionEntry, id)
	return err
}

const upsertUserCollection = `-- name: UpsertUserCollection :exec
INSERT INTO users.collections (id, applicationgroup_id, profile_id, updated_at, created_at, my_list, title)
VALUES ($1, $2, $3, now(), now(), $4, $5)
ON CONFLICT (id) DO UPDATE SET updated_at = now(),
                               title      = EXCLUDED.title
`

type UpsertUserCollectionParams struct {
	ID                 uuid.UUID `db:"id" json:"id"`
	ApplicationgroupID uuid.UUID `db:"applicationgroup_id" json:"applicationgroupID"`
	ProfileID          uuid.UUID `db:"profile_id" json:"profileID"`
	MyList             bool      `db:"my_list" json:"myList"`
	Title              string    `db:"title" json:"title"`
}

func (q *Queries) UpsertUserCollection(ctx context.Context, arg UpsertUserCollectionParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserCollection,
		arg.ID,
		arg.ApplicationgroupID,
		arg.ProfileID,
		arg.MyList,
		arg.Title,
	)
	return err
}

const upsertUserCollectionEntry = `-- name: UpsertUserCollectionEntry :exec
INSERT INTO users.collectionentries (id, collection_id, sort, type, item_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, now(), now())
ON CONFLICT(id) DO UPDATE SET sort       = EXCLUDED.sort,
                              updated_at = EXCLUDED.updated_at
`

type UpsertUserCollectionEntryParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	CollectionID uuid.UUID `db:"collection_id" json:"collectionID"`
	Sort         int32     `db:"sort" json:"sort"`
	Type         string    `db:"type" json:"type"`
	ItemID       uuid.UUID `db:"item_id" json:"itemID"`
}

func (q *Queries) UpsertUserCollectionEntry(ctx context.Context, arg UpsertUserCollectionEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserCollectionEntry,
		arg.ID,
		arg.CollectionID,
		arg.Sort,
		arg.Type,
		arg.ItemID,
	)
	return err
}

const getMyListCollectionForProfileIDs = `-- name: getMyListCollectionForProfileIDs :many
SELECT c.id, c.profile_id AS parent_id
FROM users.collections c
WHERE c.profile_id = ANY ($1::uuid[])
  AND my_list
`

type getMyListCollectionForProfileIDsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentID"`
}

func (q *Queries) getMyListCollectionForProfileIDs(ctx context.Context, profileIds []uuid.UUID) ([]getMyListCollectionForProfileIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMyListCollectionForProfileIDs, pq.Array(profileIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getMyListCollectionForProfileIDsRow
	for rows.Next() {
		var i getMyListCollectionForProfileIDsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectionEntries = `-- name: getUserCollectionEntries :many
SELECT ce.id, ce.collection_id, ce.updated_at, ce.created_at, ce.sort, ce.type, ce.item_id
FROM users.collectionentries ce
WHERE ce.id = ANY ($1::uuid[])
`

type getUserCollectionEntriesRow struct {
	ID           uuid.UUID `db:"id" json:"id"`
	CollectionID uuid.UUID `db:"collection_id" json:"collectionID"`
	UpdatedAt    time.Time `db:"updated_at" json:"updatedAt"`
	CreatedAt    time.Time `db:"created_at" json:"createdAt"`
	Sort         int32     `db:"sort" json:"sort"`
	Type         string    `db:"type" json:"type"`
	ItemID       uuid.UUID `db:"item_id" json:"itemID"`
}

func (q *Queries) getUserCollectionEntries(ctx context.Context, ids []uuid.UUID) ([]getUserCollectionEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionEntries, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionEntriesRow
	for rows.Next() {
		var i getUserCollectionEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Sort,
			&i.Type,
			&i.ItemID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectionEntryIDsForUserCollectionIDs = `-- name: getUserCollectionEntryIDsForUserCollectionIDs :many
SELECT ce.id, ce.collection_id AS parent_id
FROM users.collectionentries ce
WHERE ce.collection_id = ANY ($1::uuid[])
ORDER BY ce.updated_at DESC
`

type getUserCollectionEntryIDsForUserCollectionIDsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentID"`
}

func (q *Queries) getUserCollectionEntryIDsForUserCollectionIDs(ctx context.Context, collectionIds []uuid.UUID) ([]getUserCollectionEntryIDsForUserCollectionIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionEntryIDsForUserCollectionIDs, pq.Array(collectionIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionEntryIDsForUserCollectionIDsRow
	for rows.Next() {
		var i getUserCollectionEntryIDsForUserCollectionIDsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectionIDsForProfileIDs = `-- name: getUserCollectionIDsForProfileIDs :many
SELECT c.id, c.profile_id AS parent_id
FROM users.collections c
WHERE c.profile_id = ANY ($1::uuid[])
  AND my_list
`

type getUserCollectionIDsForProfileIDsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentID"`
}

func (q *Queries) getUserCollectionIDsForProfileIDs(ctx context.Context, profileIds []uuid.UUID) ([]getUserCollectionIDsForProfileIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectionIDsForProfileIDs, pq.Array(profileIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionIDsForProfileIDsRow
	for rows.Next() {
		var i getUserCollectionIDsForProfileIDsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollections = `-- name: getUserCollections :many
SELECT c.id, c.applicationgroup_id, c.profile_id, c.updated_at, c.created_at, c.title, c.my_list
FROM users.collections c
WHERE id = ANY ($1::uuid[])
`

type getUserCollectionsRow struct {
	ID                 uuid.UUID `db:"id" json:"id"`
	ApplicationgroupID uuid.UUID `db:"applicationgroup_id" json:"applicationgroupID"`
	ProfileID          uuid.UUID `db:"profile_id" json:"profileID"`
	UpdatedAt          time.Time `db:"updated_at" json:"updatedAt"`
	CreatedAt          time.Time `db:"created_at" json:"createdAt"`
	Title              string    `db:"title" json:"title"`
	MyList             bool      `db:"my_list" json:"myList"`
}

func (q *Queries) getUserCollections(ctx context.Context, ids []uuid.UUID) ([]getUserCollectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollections, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUserCollectionsRow
	for rows.Next() {
		var i getUserCollectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ApplicationgroupID,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Title,
			&i.MyList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
