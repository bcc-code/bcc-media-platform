// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: episodes_test.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	null_v4 "gopkg.in/guregu/null.v4"
)

const addEpisode = `-- name: AddEpisode :one

INSERT INTO episodes (asset_id, episode_number,
                      publish_date, season_id, user_created, user_updated, publish_date_in_title, label,
                      production_date, public_title, prevent_public_indexing, uuid, content_type, audience,
                      status,  available_from, available_to, mediaitem_id)
VALUES ($1,
        $2,
        $3::timestamp,
        $4,
        $5::uuid,
        $6::uuid,
        $7,
        $8,
        $9,
        $10,
        $11::bool,
        $12::uuid,
        $13,
        $14,
        $15,
    $16::timestamp,
    $17::timestamp,
    $18::uuid
       )
RETURNING agerating_code, asset_id, available_from, available_to, date_created, date_updated, episode_number, id, image_file_id, legacy_description_id, legacy_extra_description_id, legacy_id, legacy_program_id, legacy_tags_id, legacy_title_id, migration_data, publish_date, season_id, status, type, user_created, user_updated, publish_date_in_title, label, production_date, public_title, prevent_public_indexing, uuid, content_type, audience, timedmetadata_from_asset, translations_required, mediaitem_id
`

type AddEpisodeParams struct {
	AssetID               null_v4.Int    `db:"asset_id" json:"assetId"`
	EpisodeNumber         null_v4.Int    `db:"episode_number" json:"episodeNumber"`
	PublishDate           time.Time      `db:"publish_date" json:"publishDate"`
	SeasonID              null_v4.Int    `db:"season_id" json:"seasonId"`
	UserCreated           uuid.UUID      `db:"user_created" json:"userCreated"`
	UserUpdated           uuid.UUID      `db:"user_updated" json:"userUpdated"`
	PublishDateInTitle    sql.NullBool   `db:"publish_date_in_title" json:"publishDateInTitle"`
	Label                 null_v4.String `db:"label" json:"label"`
	ProductionDate        null_v4.Time   `db:"production_date" json:"productionDate"`
	PublicTitle           null_v4.String `db:"public_title" json:"publicTitle"`
	PreventPublicIndexing bool           `db:"prevent_public_indexing" json:"preventPublicIndexing"`
	Uuid                  uuid.UUID      `db:"uuid" json:"uuid"`
	ContentType           null_v4.String `db:"content_type" json:"contentType"`
	Audience              null_v4.String `db:"audience" json:"audience"`
	Status                string         `db:"status" json:"status"`
	AvailableFrom         time.Time      `db:"available_from" json:"availableFrom"`
	AvailableTo           time.Time      `db:"available_to" json:"availableTo"`
	MediaitemID           uuid.UUID      `db:"mediaitem_id" json:"mediaitemId"`
}

func (q *Queries) AddEpisode(ctx context.Context, arg AddEpisodeParams) (Episode, error) {
	row := q.db.QueryRowContext(ctx, addEpisode,
		arg.AssetID,
		arg.EpisodeNumber,
		arg.PublishDate,
		arg.SeasonID,
		arg.UserCreated,
		arg.UserUpdated,
		arg.PublishDateInTitle,
		arg.Label,
		arg.ProductionDate,
		arg.PublicTitle,
		arg.PreventPublicIndexing,
		arg.Uuid,
		arg.ContentType,
		arg.Audience,
		arg.Status,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.MediaitemID,
	)
	var i Episode
	err := row.Scan(
		&i.AgeratingCode,
		&i.AssetID,
		&i.AvailableFrom,
		&i.AvailableTo,
		&i.DateCreated,
		&i.DateUpdated,
		&i.EpisodeNumber,
		&i.ID,
		&i.ImageFileID,
		&i.LegacyDescriptionID,
		&i.LegacyExtraDescriptionID,
		&i.LegacyID,
		&i.LegacyProgramID,
		&i.LegacyTagsID,
		&i.LegacyTitleID,
		&i.MigrationData,
		&i.PublishDate,
		&i.SeasonID,
		&i.Status,
		&i.Type,
		&i.UserCreated,
		&i.UserUpdated,
		&i.PublishDateInTitle,
		&i.Label,
		&i.ProductionDate,
		&i.PublicTitle,
		&i.PreventPublicIndexing,
		&i.Uuid,
		&i.ContentType,
		&i.Audience,
		&i.TimedmetadataFromAsset,
		&i.TranslationsRequired,
		&i.MediaitemID,
	)
	return i, err
}

const addMediaItem = `-- name: AddMediaItem :one

INSERT INTO mediaitems (id, user_created, date_created, user_updated, date_updated, label, title, description, asset_id,
                        parent_episode_id, parent_starts_at, parent_ends_at, published_at, production_date, parent_id,
                        content_type, audience, agerating_code, available_from, available_to, primary_episode_id, type)
VALUES ($1,
        $2::uuid,
        $3,
        $4::uuid,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20, $21, $22) RETURNING id
`

type AddMediaItemParams struct {
	ID               uuid.UUID       `db:"id" json:"id"`
	UserCreated      uuid.UUID       `db:"user_created" json:"userCreated"`
	DateCreated      null_v4.Time    `db:"date_created" json:"dateCreated"`
	UserUpdated      uuid.UUID       `db:"user_updated" json:"userUpdated"`
	DateUpdated      null_v4.Time    `db:"date_updated" json:"dateUpdated"`
	Label            string          `db:"label" json:"label"`
	Title            null_v4.String  `db:"title" json:"title"`
	Description      null_v4.String  `db:"description" json:"description"`
	AssetID          null_v4.Int     `db:"asset_id" json:"assetId"`
	ParentEpisodeID  null_v4.Int     `db:"parent_episode_id" json:"parentEpisodeId"`
	ParentStartsAt   sql.NullFloat64 `db:"parent_starts_at" json:"parentStartsAt"`
	ParentEndsAt     sql.NullFloat64 `db:"parent_ends_at" json:"parentEndsAt"`
	PublishedAt      null_v4.Time    `db:"published_at" json:"publishedAt"`
	ProductionDate   null_v4.Time    `db:"production_date" json:"productionDate"`
	ParentID         uuid.NullUUID   `db:"parent_id" json:"parentId"`
	ContentType      null_v4.String  `db:"content_type" json:"contentType"`
	Audience         null_v4.String  `db:"audience" json:"audience"`
	AgeratingCode    null_v4.String  `db:"agerating_code" json:"ageratingCode"`
	AvailableFrom    null_v4.Time    `db:"available_from" json:"availableFrom"`
	AvailableTo      null_v4.Time    `db:"available_to" json:"availableTo"`
	PrimaryEpisodeID null_v4.Int     `db:"primary_episode_id" json:"primaryEpisodeId"`
	Type             string          `db:"type" json:"type"`
}

func (q *Queries) AddMediaItem(ctx context.Context, arg AddMediaItemParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, addMediaItem,
		arg.ID,
		arg.UserCreated,
		arg.DateCreated,
		arg.UserUpdated,
		arg.DateUpdated,
		arg.Label,
		arg.Title,
		arg.Description,
		arg.AssetID,
		arg.ParentEpisodeID,
		arg.ParentStartsAt,
		arg.ParentEndsAt,
		arg.PublishedAt,
		arg.ProductionDate,
		arg.ParentID,
		arg.ContentType,
		arg.Audience,
		arg.AgeratingCode,
		arg.AvailableFrom,
		arg.AvailableTo,
		arg.PrimaryEpisodeID,
		arg.Type,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
