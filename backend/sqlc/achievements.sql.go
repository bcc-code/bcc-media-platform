// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: achievements.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
	null_v4 "gopkg.in/guregu/null.v4"
)

const addStudytopicFilterToCondition = `-- name: AddStudytopicFilterToCondition :exec
INSERT INTO "achievementconditions_studytopics" (achievementconditions_id, studytopics_id)
VALUES ($1::uuid, $2::uuid)
`

type AddStudytopicFilterToConditionParams struct {
	ConditionID  uuid.UUID `db:"condition_id" json:"conditionId"`
	StudytopicID uuid.UUID `db:"studytopic_id" json:"studytopicId"`
}

func (q *Queries) AddStudytopicFilterToCondition(ctx context.Context, arg AddStudytopicFilterToConditionParams) error {
	_, err := q.db.ExecContext(ctx, addStudytopicFilterToCondition, arg.ConditionID, arg.StudytopicID)
	return err
}

const confirmAchievement = `-- name: ConfirmAchievement :exec
UPDATE "users"."achievements"
SET confirmed_at = NOW()
WHERE profile_id = $1
  AND achievement_id = $2
`

type ConfirmAchievementParams struct {
	ProfileID     uuid.UUID `db:"profile_id" json:"profileId"`
	AchievementID uuid.UUID `db:"achievement_id" json:"achievementId"`
}

func (q *Queries) ConfirmAchievement(ctx context.Context, arg ConfirmAchievementParams) error {
	_, err := q.db.ExecContext(ctx, confirmAchievement, arg.ProfileID, arg.AchievementID)
	return err
}

const createAchievement = `-- name: CreateAchievement :one

INSERT INTO "achievements" (
                                     id,
    status,
    user_created,
    date_created,
    group_id,
    title,
    description,
    sort
) VALUES (
             gen_random_uuid(),
             $1,
             $2::uuid,
             now(),
             $3::uuid,
             $4,
             $5,
             $6
         ) returning id
`

type CreateAchievementParams struct {
	Status      string         `db:"status" json:"status"`
	UserCreated uuid.UUID      `db:"user_created" json:"userCreated"`
	GroupID     uuid.UUID      `db:"group_id" json:"groupId"`
	Title       string         `db:"title" json:"title"`
	Description null_v4.String `db:"description" json:"description"`
	Sort        null_v4.Int    `db:"sort" json:"sort"`
}

func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createAchievement,
		arg.Status,
		arg.UserCreated,
		arg.GroupID,
		arg.Title,
		arg.Description,
		arg.Sort,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createAchievementGroup = `-- name: CreateAchievementGroup :one
INSERT INTO "achievementgroups" (id, user_created, date_created, title) VALUES (
                                                                                        gen_random_uuid(),
                                                                                        $1::uuid,
                                                                                        now(),
                                                                                        $2
                                                                                    ) RETURNING id
`

type CreateAchievementGroupParams struct {
	UserCreated uuid.UUID      `db:"user_created" json:"userCreated"`
	Title       null_v4.String `db:"title" json:"title"`
}

func (q *Queries) CreateAchievementGroup(ctx context.Context, arg CreateAchievementGroupParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createAchievementGroup, arg.UserCreated, arg.Title)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createCondition = `-- name: CreateCondition :one
INSERT INTO "achievementconditions" (id, collection, action, amount, achievement_id)
VALUES (gen_random_uuid(), $1, $2, $3, $4) RETURNING id
`

type CreateConditionParams struct {
	Collection    string      `db:"collection" json:"collection"`
	Action        string      `db:"action" json:"action"`
	Amount        null_v4.Int `db:"amount" json:"amount"`
	AchievementID uuid.UUID   `db:"achievement_id" json:"achievementId"`
}

func (q *Queries) CreateCondition(ctx context.Context, arg CreateConditionParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createCondition,
		arg.Collection,
		arg.Action,
		arg.Amount,
		arg.AchievementID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
                   id,
                   user_created,
                   date_created,
                   question_type,
                   lesson_id,
                   title,
                   type,
                   status
)
VALUES (
          gen_random_uuid(),
          $1::uuid,
          now(),
          $2,
          $3::uuid,
          $4,
        $5,
        $6
       ) returning id
`

type CreateTaskParams struct {
	UserCreated  uuid.UUID      `db:"user_created" json:"userCreated"`
	QuestionType null_v4.String `db:"question_type" json:"questionType"`
	LessonID     uuid.UUID      `db:"lesson_id" json:"lessonId"`
	Title        null_v4.String `db:"title" json:"title"`
	Type         string         `db:"type" json:"type"`
	Status       string         `db:"status" json:"status"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.UserCreated,
		arg.QuestionType,
		arg.LessonID,
		arg.Title,
		arg.Type,
		arg.Status,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAchievedAchievements = `-- name: GetAchievedAchievements :many
SELECT a.achievement_id as id
FROM "users"."achievements" a
WHERE a.profile_id = $1
  AND a.achievement_id = ANY ($2::uuid[])
`

type GetAchievedAchievementsParams struct {
	ProfileID      uuid.UUID   `db:"profile_id" json:"profileId"`
	AchievementIds []uuid.UUID `db:"achievement_ids" json:"achievementIds"`
}

func (q *Queries) GetAchievedAchievements(ctx context.Context, arg GetAchievedAchievementsParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getAchievedAchievements, arg.ProfileID, pq.Array(arg.AchievementIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievementsWithConditionAmountAchieved = `-- name: GetAchievementsWithConditionAmountAchieved :many
SELECT c.achievement_id AS id, array_agg(c.id)::uuid[] AS condition_ids
FROM "public"."achievementconditions" c
         LEFT JOIN "users"."achievements" achieved
                   ON achieved.profile_id = $1 AND achieved.achievement_id = c.achievement_id
WHERE achieved IS NULL
  AND c.collection = $2
  AND c.action = $3
  AND c.amount <= $4
GROUP BY c.achievement_id
`

type GetAchievementsWithConditionAmountAchievedParams struct {
	ProfileID  uuid.UUID   `db:"profile_id" json:"profileId"`
	Collection string      `db:"collection" json:"collection"`
	Action     string      `db:"action" json:"action"`
	Amount     null_v4.Int `db:"amount" json:"amount"`
}

type GetAchievementsWithConditionAmountAchievedRow struct {
	ID           uuid.UUID   `db:"id" json:"id"`
	ConditionIds []uuid.UUID `db:"condition_ids" json:"conditionIds"`
}

func (q *Queries) GetAchievementsWithConditionAmountAchieved(ctx context.Context, arg GetAchievementsWithConditionAmountAchievedParams) ([]GetAchievementsWithConditionAmountAchievedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievementsWithConditionAmountAchieved,
		arg.ProfileID,
		arg.Collection,
		arg.Action,
		arg.Amount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchievementsWithConditionAmountAchievedRow
	for rows.Next() {
		var i GetAchievementsWithConditionAmountAchievedRow
		if err := rows.Scan(&i.ID, pq.Array(&i.ConditionIds)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievementsWithTopicsCompletedAchieved = `-- name: GetAchievementsWithTopicsCompletedAchieved :many
SELECT c.achievement_id AS id, array_agg(c.id)::uuid[] AS condition_ids
FROM "public"."achievementconditions" c
         LEFT JOIN "users"."achievements" achieved
                   ON achieved.profile_id = $1 AND achieved.achievement_id = c.achievement_id
         LEFT JOIN "public"."achievementconditions_studytopics" t ON t.achievementconditions_id = c.id
WHERE achieved IS NULL
  AND c.collection = 'topics'
  AND t.studytopics_id = ANY ($2::uuid[])
GROUP BY c.achievement_id
`

type GetAchievementsWithTopicsCompletedAchievedParams struct {
	ProfileID uuid.UUID   `db:"profile_id" json:"profileId"`
	TopicIds  []uuid.UUID `db:"topic_ids" json:"topicIds"`
}

type GetAchievementsWithTopicsCompletedAchievedRow struct {
	ID           uuid.UUID   `db:"id" json:"id"`
	ConditionIds []uuid.UUID `db:"condition_ids" json:"conditionIds"`
}

func (q *Queries) GetAchievementsWithTopicsCompletedAchieved(ctx context.Context, arg GetAchievementsWithTopicsCompletedAchievedParams) ([]GetAchievementsWithTopicsCompletedAchievedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievementsWithTopicsCompletedAchieved, arg.ProfileID, pq.Array(arg.TopicIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchievementsWithTopicsCompletedAchievedRow
	for rows.Next() {
		var i GetAchievementsWithTopicsCompletedAchievedRow
		if err := rows.Scan(&i.ID, pq.Array(&i.ConditionIds)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchieventGroupsTranslatableTexts = `-- name: GetAchieventGroupsTranslatableTexts :many
SELECT id, title FROM achievementgroups a WHERE a.status = ANY ('{published,unlisted}')
                                                        AND (a.date_updated > $1::timestamp OR a.date_updated IS NULL)
`

type GetAchieventGroupsTranslatableTextsRow struct {
	ID    uuid.UUID      `db:"id" json:"id"`
	Title null_v4.String `db:"title" json:"title"`
}

func (q *Queries) GetAchieventGroupsTranslatableTexts(ctx context.Context, dateUpdated time.Time) ([]GetAchieventGroupsTranslatableTextsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchieventGroupsTranslatableTexts, dateUpdated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchieventGroupsTranslatableTextsRow
	for rows.Next() {
		var i GetAchieventGroupsTranslatableTextsRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchieventsTranslatableTexts = `-- name: GetAchieventsTranslatableTexts :many
SELECT id, title, description FROM achievements a
                              WHERE a.status = ANY ('{published,unlisted}')
                                AND (a.date_updated > $1::timestamp OR a.date_updated IS NULL)
`

type GetAchieventsTranslatableTextsRow struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	Title       string         `db:"title" json:"title"`
	Description null_v4.String `db:"description" json:"description"`
}

func (q *Queries) GetAchieventsTranslatableTexts(ctx context.Context, dateUpdated time.Time) ([]GetAchieventsTranslatableTextsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchieventsTranslatableTexts, dateUpdated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAchieventsTranslatableTextsRow
	for rows.Next() {
		var i GetAchieventsTranslatableTextsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewConditionsForProfile = `-- name: GetNewConditionsForProfile :many
SELECT
    ac.achievement_id::uuid achievement_id,
    ac.id::uuid condition_id,
    ac.action,
    ac.collection,
    coalesce(ac.amount, 0)::int amount,
    COALESCE(array_agg(st.studytopics_id) FILTER (WHERE studytopics_id IS NOT NULL), '{}')::uuid[] studytopics
FROM achievements a
                                                                                                      LEFT JOIN users.achievements ua ON ua.profile_id = $1::uuid AND a.id = ua.achievement_id
                                                                                                      LEFT JOIN achievementconditions ac ON ac.achievement_id = a.id
                                                                                                      LEFT JOIN achievementconditions_studytopics st ON ac.id = st.achievementconditions_id
WHERE status = 'published'
  AND action = 'completed'
  AND profile_id IS NULL
GROUP BY ac.id
`

type GetNewConditionsForProfileRow struct {
	AchievementID uuid.UUID      `db:"achievement_id" json:"achievementId"`
	ConditionID   uuid.UUID      `db:"condition_id" json:"conditionId"`
	Action        null_v4.String `db:"action" json:"action"`
	Collection    null_v4.String `db:"collection" json:"collection"`
	Amount        int32          `db:"amount" json:"amount"`
	Studytopics   []uuid.UUID    `db:"studytopics" json:"studytopics"`
}

func (q *Queries) GetNewConditionsForProfile(ctx context.Context, profileID uuid.UUID) ([]GetNewConditionsForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, getNewConditionsForProfile, profileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewConditionsForProfileRow
	for rows.Next() {
		var i GetNewConditionsForProfileRow
		if err := rows.Scan(
			&i.AchievementID,
			&i.ConditionID,
			&i.Action,
			&i.Collection,
			&i.Amount,
			pq.Array(&i.Studytopics),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementGroups = `-- name: ListAchievementGroups :many
SELECT id
FROM "public"."achievementgroups"
WHERE status = 'published'
`

func (q *Queries) ListAchievementGroups(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, listAchievementGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievements = `-- name: ListAchievements :many
SELECT id
FROM "public"."achievements"
WHERE status = 'published'
ORDER BY sort
`

func (q *Queries) ListAchievements(ctx context.Context) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, listAchievements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAchievementAchieved = `-- name: SetAchievementAchieved :exec
INSERT INTO "users"."achievements" (profile_id, achievement_id, achieved_at, condition_ids)
VALUES ($1, $2, now(), $3)
ON CONFLICT(profile_id, achievement_id) DO UPDATE SET achieved_at = now()
`

type SetAchievementAchievedParams struct {
	ProfileID     uuid.UUID   `db:"profile_id" json:"profileId"`
	AchievementID uuid.UUID   `db:"achievement_id" json:"achievementId"`
	ConditionIds  []uuid.UUID `db:"condition_ids" json:"conditionIds"`
}

func (q *Queries) SetAchievementAchieved(ctx context.Context, arg SetAchievementAchievedParams) error {
	_, err := q.db.ExecContext(ctx, setAchievementAchieved, arg.ProfileID, arg.AchievementID, pq.Array(arg.ConditionIds))
	return err
}

const achievementAchievedAt = `-- name: achievementAchievedAt :many
SELECT a.achievement_id,
       a.achieved_at,
       a.confirmed_at
FROM "users"."achievements" a
WHERE a.profile_id = $1
  AND a.achievement_id = ANY ($2::uuid[])
`

type achievementAchievedAtParams struct {
	ProfileID uuid.UUID   `db:"profile_id" json:"profileId"`
	Column2   []uuid.UUID `db:"column_2" json:"column2"`
}

type achievementAchievedAtRow struct {
	AchievementID uuid.UUID    `db:"achievement_id" json:"achievementId"`
	AchievedAt    time.Time    `db:"achieved_at" json:"achievedAt"`
	ConfirmedAt   null_v4.Time `db:"confirmed_at" json:"confirmedAt"`
}

func (q *Queries) achievementAchievedAt(ctx context.Context, arg achievementAchievedAtParams) ([]achievementAchievedAtRow, error) {
	rows, err := q.db.QueryContext(ctx, achievementAchievedAt, arg.ProfileID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []achievementAchievedAtRow
	for rows.Next() {
		var i achievementAchievedAtRow
		if err := rows.Scan(&i.AchievementID, &i.AchievedAt, &i.ConfirmedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completedLessonsByTopic = `-- name: completedLessonsByTopic :many
WITH total AS (SELECT l.topic_id, t.lesson_id,
                      COUNT(t.id) task_count
               FROM tasks t
                        JOIN lessons l ON l.id = t.lesson_id
               WHERE t.status = 'published'
               GROUP BY l.topic_id, t.lesson_id),
     completed AS (SELECT l.topic_id, t.lesson_id, ta.profile_id, COUNT(t.id) completed_count
                   FROM tasks t
                            JOIN lessons l ON l.id = t.lesson_id
                            JOIN "users"."taskanswers" ta ON ta.task_id = t.id
                   GROUP BY l.topic_id, t.lesson_id, ta.profile_id)
SELECT total.topic_id as topic_id, completed.lesson_id::uuid as lesson_id, completed.profile_id::uuid as profile_id
FROM completed
         JOIN total ON total.lesson_id = completed.lesson_id
WHERE completed.profile_id = ANY ($1::uuid[]) AND
      completed.completed_count >= total.task_count
GROUP BY total.topic_id, completed.lesson_id::uuid, completed.profile_id::uuid
`

type completedLessonsByTopicRow struct {
	TopicID   uuid.UUID `db:"topic_id" json:"topicId"`
	LessonID  uuid.UUID `db:"lesson_id" json:"lessonId"`
	ProfileID uuid.UUID `db:"profile_id" json:"profileId"`
}

func (q *Queries) completedLessonsByTopic(ctx context.Context, profileIds []uuid.UUID) ([]completedLessonsByTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, completedLessonsByTopic, pq.Array(profileIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []completedLessonsByTopicRow
	for rows.Next() {
		var i completedLessonsByTopicRow
		if err := rows.Scan(&i.TopicID, &i.LessonID, &i.ProfileID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievedAchievementsForProfiles = `-- name: getAchievedAchievementsForProfiles :many
SELECT a.achievement_id as id, a.profile_id as parent_id
FROM "users"."achievements" a
WHERE a.profile_id = ANY ($1::uuid[])
ORDER BY a.achieved_at DESC
`

type getAchievedAchievementsForProfilesRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentId"`
}

func (q *Queries) getAchievedAchievementsForProfiles(ctx context.Context, dollar_1 []uuid.UUID) ([]getAchievedAchievementsForProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievedAchievementsForProfiles, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAchievedAchievementsForProfilesRow
	for rows.Next() {
		var i getAchievedAchievementsForProfilesRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievementGroups = `-- name: getAchievementGroups :many
WITH ts AS (SELECT achievementgroups_id, json_object_agg(languages_code, title) as title
            FROM achievementgroups_translations
            GROUP BY achievementgroups_id)
SELECT ag.id, ag.title as original_title, ts.title
FROM achievementgroups ag
         LEFT JOIN ts ON ts.achievementgroups_id = ag.id
WHERE ag.id = ANY ($1::uuid[])
`

type getAchievementGroupsRow struct {
	ID            uuid.UUID             `db:"id" json:"id"`
	OriginalTitle null_v4.String        `db:"original_title" json:"originalTitle"`
	Title         pqtype.NullRawMessage `db:"title" json:"title"`
}

func (q *Queries) getAchievementGroups(ctx context.Context, dollar_1 []uuid.UUID) ([]getAchievementGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievementGroups, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAchievementGroupsRow
	for rows.Next() {
		var i getAchievementGroupsRow
		if err := rows.Scan(&i.ID, &i.OriginalTitle, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievements = `-- name: getAchievements :many
WITH ts AS (SELECT achievements_id,
                   json_object_agg(languages_code, title)       as title,
                   json_object_agg(languages_code, description) as description
            FROM achievements_translations
            GROUP BY achievements_id),
     cons AS (SELECT achievement_id,
                     json_agg(c) as conditions
              FROM achievementconditions c
              GROUP BY achievement_id),
     images AS (SELECT achievement_id, json_object_agg(COALESCE(language, 'no'), df.filename_disk) as images
                FROM achievements_images
                         JOIN directus_files df on achievements_images.image = df.id
                GROUP BY achievement_id)
SELECT a.id,
       a.group_id,
       a.title       as original_title,
       a.description as original_description,
       ts.title,
       ts.description,
       images.images,
       cons.conditions
FROM "public"."achievements" a
         LEFT JOIN ts ON ts.achievements_id = a.id
         LEFT JOIN cons ON cons.achievement_id = a.id
         LEFT JOIN images ON images.achievement_id = a.id
WHERE a.id = ANY ($1::uuid[])
ORDER BY sort
`

type getAchievementsRow struct {
	ID                  uuid.UUID             `db:"id" json:"id"`
	GroupID             uuid.NullUUID         `db:"group_id" json:"groupId"`
	OriginalTitle       string                `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String        `db:"original_description" json:"originalDescription"`
	Title               pqtype.NullRawMessage `db:"title" json:"title"`
	Description         pqtype.NullRawMessage `db:"description" json:"description"`
	Images              pqtype.NullRawMessage `db:"images" json:"images"`
	Conditions          pqtype.NullRawMessage `db:"conditions" json:"conditions"`
}

func (q *Queries) getAchievements(ctx context.Context, dollar_1 []uuid.UUID) ([]getAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievements, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAchievementsRow
	for rows.Next() {
		var i getAchievementsRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Images,
			&i.Conditions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievementsForActions = `-- name: getAchievementsForActions :many
SELECT achievement_id::uuid as id, action::varchar as parent_id
FROM achievementconditions
WHERE collection = $1::varchar
  AND action = ANY ($2::varchar[])
`

type getAchievementsForActionsParams struct {
	Column1 string   `db:"column_1" json:"column1"`
	Column2 []string `db:"column_2" json:"column2"`
}

type getAchievementsForActionsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID string    `db:"parent_id" json:"parentId"`
}

func (q *Queries) getAchievementsForActions(ctx context.Context, arg getAchievementsForActionsParams) ([]getAchievementsForActionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievementsForActions, arg.Column1, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAchievementsForActionsRow
	for rows.Next() {
		var i getAchievementsForActionsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAchievementsForGroups = `-- name: getAchievementsForGroups :many
SELECT id, group_id::uuid as parent_id
FROM "public"."achievements"
WHERE group_id = ANY ($1::uuid[])
ORDER BY sort
`

type getAchievementsForGroupsRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentId"`
}

func (q *Queries) getAchievementsForGroups(ctx context.Context, dollar_1 []uuid.UUID) ([]getAchievementsForGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAchievementsForGroups, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getAchievementsForGroupsRow
	for rows.Next() {
		var i getAchievementsForGroupsRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnconfirmedAchievedAchievementsForProfiles = `-- name: getUnconfirmedAchievedAchievementsForProfiles :many
SELECT a.achievement_id as id, a.profile_id as parent_id
FROM "users"."achievements" a
WHERE a.profile_id = ANY ($1::uuid[])
  AND a.confirmed_at IS NULL
`

type getUnconfirmedAchievedAchievementsForProfilesRow struct {
	ID       uuid.UUID `db:"id" json:"id"`
	ParentID uuid.UUID `db:"parent_id" json:"parentId"`
}

func (q *Queries) getUnconfirmedAchievedAchievementsForProfiles(ctx context.Context, dollar_1 []uuid.UUID) ([]getUnconfirmedAchievedAchievementsForProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnconfirmedAchievedAchievementsForProfiles, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getUnconfirmedAchievedAchievementsForProfilesRow
	for rows.Next() {
		var i getUnconfirmedAchievedAchievementsForProfilesRow
		if err := rows.Scan(&i.ID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
