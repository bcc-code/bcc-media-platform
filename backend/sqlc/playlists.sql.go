// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: playlists.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const getRolesForPlaylists = `-- name: GetRolesForPlaylists :many
SELECT roles.playlists_id, array_agg(roles.usergroups_code)::varchar[] AS roles
FROM playlists_usergroups roles
WHERE roles.playlists_id = ANY ($1::uuid[])
GROUP BY roles.playlists_id
`

type GetRolesForPlaylistsRow struct {
	PlaylistsID uuid.UUID `db:"playlists_id" json:"playlistsId"`
	Roles       []string  `db:"roles" json:"roles"`
}

func (q *Queries) GetRolesForPlaylists(ctx context.Context, ids []uuid.UUID) ([]GetRolesForPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRolesForPlaylists, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesForPlaylistsRow
	for rows.Next() {
		var i GetRolesForPlaylistsRow
		if err := rows.Scan(&i.PlaylistsID, pq.Array(&i.Roles)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylists = `-- name: getPlaylists :many
SELECT p.id,
       p.collection_id,
       p.title                                     AS original_title,
       p.description                               AS original_description,
       coalesce(title_agg.title, '{}')             AS title,
       coalesce(description_agg.description, '{}') AS description,
       coalesce(images_agg.images, '{}')           AS images
FROM public.playlists p
         LEFT JOIN (SELECT ts.playlists_id, json_object_agg(ts.languages_code, ts.title) AS title
                    FROM playlists_translations ts
                    GROUP BY ts.playlists_id) AS title_agg ON title_agg.playlists_id = p.id
         LEFT JOIN (SELECT ts.playlists_id, json_object_agg(ts.languages_code, ts.description) AS description
                    FROM playlists_translations ts
                    GROUP BY ts.playlists_id) AS description_agg ON description_agg.playlists_id = p.id
         LEFT JOIN (SELECT simg.playlists_id,
                           json_agg(json_build_object('style', img.style, 'language', img.language, 'filename_disk',
                                                      df.filename_disk)) AS images
                    FROM playlists_styledimages simg
                             JOIN styledimages img ON img.id = simg.styledimages_id
                             JOIN directus_files df ON img.file = df.id
                    GROUP BY simg.playlists_id) AS images_agg ON images_agg.playlists_id = p.id
WHERE p.id = ANY ($1::uuid[])
`

type getPlaylistsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	CollectionID        null_v4.Int     `db:"collection_id" json:"collectionId"`
	OriginalTitle       string          `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Images              json.RawMessage `db:"images" json:"images"`
}

func (q *Queries) getPlaylists(ctx context.Context, ids []uuid.UUID) ([]getPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylists, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getPlaylistsRow
	for rows.Next() {
		var i getPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: listPlaylists :many
SELECT p.id,
       p.collection_id,
       p.title                                     AS original_title,
       p.description                               AS original_description,
       coalesce(title_agg.title, '{}')             AS title,
       coalesce(description_agg.description, '{}') AS description,
       coalesce(images_agg.images, '{}')           AS images
FROM public.playlists p
         LEFT JOIN (SELECT ts.playlists_id, json_object_agg(ts.languages_code, ts.title) AS title
                    FROM playlists_translations ts
                    GROUP BY ts.playlists_id) AS title_agg ON title_agg.playlists_id = p.id
         LEFT JOIN (SELECT ts.playlists_id, json_object_agg(ts.languages_code, ts.description) AS description
                    FROM playlists_translations ts
                    GROUP BY ts.playlists_id) AS description_agg ON description_agg.playlists_id = p.id
         LEFT JOIN (SELECT simg.playlists_id,
                           json_agg(json_build_object('style', img.style, 'language', img.language, 'filename_disk',
                                                      df.filename_disk)) AS images
                    FROM playlists_styledimages simg
                             JOIN styledimages img ON img.id = simg.styledimages_id
                             JOIN directus_files df ON img.file = df.id
                    GROUP BY simg.playlists_id) AS images_agg ON images_agg.playlists_id = p.id
`

type listPlaylistsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	CollectionID        null_v4.Int     `db:"collection_id" json:"collectionId"`
	OriginalTitle       string          `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Images              json.RawMessage `db:"images" json:"images"`
}

func (q *Queries) listPlaylists(ctx context.Context) ([]listPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listPlaylistsRow
	for rows.Next() {
		var i listPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
