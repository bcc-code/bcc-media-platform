// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: playlists.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const getRolesForPlaylists = `-- name: GetRolesForPlaylists :many
SELECT roles.playlists_id, array_agg(roles.usergroups_code)::varchar[] AS roles
FROM playlists_usergroups roles
WHERE roles.playlists_id = ANY ($1::uuid[])
GROUP BY roles.playlists_id
`

type GetRolesForPlaylistsRow struct {
	PlaylistsID uuid.UUID `db:"playlists_id" json:"playlistsId"`
	Roles       []string  `db:"roles" json:"roles"`
}

func (q *Queries) GetRolesForPlaylists(ctx context.Context, ids []uuid.UUID) ([]GetRolesForPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRolesForPlaylists, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesForPlaylistsRow
	for rows.Next() {
		var i GetRolesForPlaylistsRow
		if err := rows.Scan(&i.PlaylistsID, pq.Array(&i.Roles)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylists = `-- name: getPlaylists :many
SELECT p.id,
       p.collection_id,
       p.title                                             AS original_title,
       p.description                                       AS original_description,
       (SELECT json_object_agg(ts.languages_code, ts.title)
        FROM playlists_translations ts
        WHERE ts.playlists_id = p.id)                      AS title,
       (SELECT json_object_agg(ts.languages_code, ts.description)
        FROM playlists_translations ts
        WHERE ts.playlists_id = p.id)                      AS description,
       (SELECT json_agg((SELECT img.style, img.language, df.filename_disk
                         FROM playlists_styledimages simg
                                  JOIN styledimages img ON img.id = simg.styledimages_id
                                  JOIN directus_files df on img.file = df.id
                         WHERE simg.playlists_id = p.id))) AS images
FROM public.playlists p
WHERE p.id = ANY ($1::uuid[])
`

type getPlaylistsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	CollectionID        null_v4.Int     `db:"collection_id" json:"collectionId"`
	OriginalTitle       string          `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Images              json.RawMessage `db:"images" json:"images"`
}

func (q *Queries) getPlaylists(ctx context.Context, ids []uuid.UUID) ([]getPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylists, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getPlaylistsRow
	for rows.Next() {
		var i getPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: listPlaylists :many
SELECT p.id,
       p.collection_id,
       p.title                                             AS original_title,
       p.description                                       AS original_description,
       (SELECT json_object_agg(ts.languages_code, ts.title)
        FROM playlists_translations ts
        WHERE ts.playlists_id = p.id)                      AS title,
       (SELECT json_object_agg(ts.languages_code, ts.description)
        FROM playlists_translations ts
        WHERE ts.playlists_id = p.id)                      AS description,
       (SELECT json_agg((SELECT img.style, img.language, df.filename_disk
                         FROM playlists_styledimages simg
                                  JOIN styledimages img ON img.id = simg.styledimages_id
                                  JOIN directus_files df on img.file = df.id
                         WHERE simg.playlists_id = p.id))) AS images
FROM public.playlists p
`

type listPlaylistsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	CollectionID        null_v4.Int     `db:"collection_id" json:"collectionId"`
	OriginalTitle       string          `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	Images              json.RawMessage `db:"images" json:"images"`
}

func (q *Queries) listPlaylists(ctx context.Context) ([]listPlaylistsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listPlaylistsRow
	for rows.Next() {
		var i listPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Title,
			&i.Description,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
