// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: shorts.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const listShortIDsForRoles = `-- name: ListShortIDsForRoles :many
SELECT s.id
FROM shorts s
         JOIN (SELECT r.shorts_id, array_agg(r.usergroups_code) as roles FROM shorts_usergroups r GROUP BY r.shorts_id) r
              ON s.id = r.shorts_id
WHERE s.status = 'published'
  AND r.roles && $1::varchar[]
`

func (q *Queries) ListShortIDsForRoles(ctx context.Context, roles []string) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, listShortIDsForRoles, pq.Array(roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaIDForShorts = `-- name: getMediaIDForShorts :many
SELECT sh.id, sh.mediaitem_id
FROM "public"."shorts" sh
WHERE sh.id = ANY ($1::uuid[])
`

type getMediaIDForShortsRow struct {
	ID          uuid.UUID     `db:"id" json:"id"`
	MediaitemID uuid.NullUUID `db:"mediaitem_id" json:"mediaitemId"`
}

func (q *Queries) getMediaIDForShorts(ctx context.Context, ids []uuid.UUID) ([]getMediaIDForShortsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMediaIDForShorts, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getMediaIDForShortsRow
	for rows.Next() {
		var i getMediaIDForShortsRow
		if err := rows.Scan(&i.ID, &i.MediaitemID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShorts = `-- name: getShorts :many
SELECT s.id,
       mi.id AS media_id,
       mi.asset_id,
       mi.title,
       mi.description,
       mi.original_title,
       mi.original_description,
       mi.images,
       mi.parent_episode_id,
       mi.parent_starts_at,
       mi.parent_ends_at
FROM shorts s
         JOIN mediaitems_view mi ON mi.id = s.mediaitem_id
WHERE s.id = ANY ($1::uuid[])
`

type getShortsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	MediaID             uuid.UUID       `db:"media_id" json:"mediaId"`
	AssetID             null_v4.Int     `db:"asset_id" json:"assetId"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	OriginalTitle       null_v4.String  `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Images              json.RawMessage `db:"images" json:"images"`
	ParentEpisodeID     null_v4.Int     `db:"parent_episode_id" json:"parentEpisodeId"`
	ParentStartsAt      sql.NullFloat64 `db:"parent_starts_at" json:"parentStartsAt"`
	ParentEndsAt        sql.NullFloat64 `db:"parent_ends_at" json:"parentEndsAt"`
}

func (q *Queries) getShorts(ctx context.Context, ids []uuid.UUID) ([]getShortsRow, error) {
	rows, err := q.db.QueryContext(ctx, getShorts, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getShortsRow
	for rows.Next() {
		var i getShortsRow
		if err := rows.Scan(
			&i.ID,
			&i.MediaID,
			&i.AssetID,
			&i.Title,
			&i.Description,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Images,
			&i.ParentEpisodeID,
			&i.ParentStartsAt,
			&i.ParentEndsAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
