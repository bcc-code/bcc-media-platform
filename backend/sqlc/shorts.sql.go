// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: shorts.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const listSegmentedShortIDsForRoles = `-- name: ListSegmentedShortIDsForRoles :many
SELECT concat(date_part('year', mi.published_at), '-', date_part('week', mi.published_at))::varchar as week,
       array_agg(s.id)::uuid[]                                                                      as ids
FROM shorts s
         JOIN mediaitems mi ON s.mediaitem_id = mi.id
         JOIN (SELECT r.shorts_id, array_agg(r.usergroups_code) as roles
               FROM shorts_usergroups r
               GROUP BY r.shorts_id) r
              ON s.id = r.shorts_id
WHERE s.status = 'published'
  AND r.roles && $1::varchar[]
GROUP BY week
ORDER BY week DESC
`

type ListSegmentedShortIDsForRolesRow struct {
	Week string      `db:"week" json:"week"`
	Ids  []uuid.UUID `db:"ids" json:"ids"`
}

func (q *Queries) ListSegmentedShortIDsForRoles(ctx context.Context, roles []string) ([]ListSegmentedShortIDsForRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSegmentedShortIDsForRoles, pq.Array(roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSegmentedShortIDsForRolesRow
	for rows.Next() {
		var i ListSegmentedShortIDsForRolesRow
		if err := rows.Scan(&i.Week, pq.Array(&i.Ids)); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSegmentedShortIDsForRolesWithScores = `-- name: ListSegmentedShortIDsForRolesWithScores :many
SELECT s.id,
       -- We need a date and if we do not have a published_at date, we need to assume that the created date is when it was published
       EXTRACT(DAY FROM current_date - COALESCE(mi.published_at, mi.date_created)) age,

       mi.parent_episode_id,

       -- For 10 days the shorts is boosted. It starts with a 5 points boost, and the boost "degrades" by 0.5
       -- points per day, reaching 0 boost on day 10. It stops there
    (((10 - LEAST(10, EXTRACT(DAY FROM current_date - COALESCE(mi.published_at, mi.date_created)))) * 0.5) + score)::float8 as final_score

FROM shorts s
         JOIN mediaitems mi ON s.mediaitem_id = mi.id
         JOIN (SELECT r.shorts_id, array_agg(r.usergroups_code) as roles
               FROM shorts_usergroups r
               GROUP BY r.shorts_id) r
              ON s.id = r.shorts_id
WHERE s.status = 'published'
  AND r.roles && $1::varchar[]
ORDER BY final_score DESC
`

type ListSegmentedShortIDsForRolesWithScoresRow struct {
	ID              uuid.UUID   `db:"id" json:"id"`
	Age             string      `db:"age" json:"age"`
	ParentEpisodeID null_v4.Int `db:"parent_episode_id" json:"parentEpisodeId"`
	FinalScore      float64     `db:"final_score" json:"finalScore"`
}

func (q *Queries) ListSegmentedShortIDsForRolesWithScores(ctx context.Context, roles []string) ([]ListSegmentedShortIDsForRolesWithScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, listSegmentedShortIDsForRolesWithScores, pq.Array(roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSegmentedShortIDsForRolesWithScoresRow
	for rows.Next() {
		var i ListSegmentedShortIDsForRolesWithScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Age,
			&i.ParentEpisodeID,
			&i.FinalScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShortsScore = `-- name: UpdateShortsScore :exec
UPDATE shorts
SET score = $1::float8
WHERE id = $2::uuid
`

type UpdateShortsScoreParams struct {
	Score float64   `db:"score" json:"score"`
	ID    uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateShortsScore(ctx context.Context, arg UpdateShortsScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateShortsScore, arg.Score, arg.ID)
	return err
}

const getMediaIDForShorts = `-- name: getMediaIDForShorts :many
SELECT sh.id, sh.mediaitem_id
FROM "public"."shorts" sh
WHERE sh.id = ANY ($1::uuid[])
`

type getMediaIDForShortsRow struct {
	ID          uuid.UUID     `db:"id" json:"id"`
	MediaitemID uuid.NullUUID `db:"mediaitem_id" json:"mediaitemId"`
}

func (q *Queries) getMediaIDForShorts(ctx context.Context, ids []uuid.UUID) ([]getMediaIDForShortsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMediaIDForShorts, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getMediaIDForShortsRow
	for rows.Next() {
		var i getMediaIDForShortsRow
		if err := rows.Scan(&i.ID, &i.MediaitemID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShorts = `-- name: getShorts :many
SELECT s.id,
       s.status,
       mi.id                                                AS media_id,
       mi.asset_id,
       mi.title,
       mi.description,
       mi.original_title,
       mi.original_description,
       mi.images,
       mi.parent_episode_id,
       mi.parent_starts_at,
       mi.parent_ends_at,
       mi.label,
       mi.tag_ids,
       GREATEST(s.date_updated, mi.date_updated)::timestamp AS date_updated
FROM shorts s
         JOIN mediaitems_view mi ON mi.id = s.mediaitem_id
WHERE s.id = ANY ($1::uuid[])
`

type getShortsRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	Status              string          `db:"status" json:"status"`
	MediaID             uuid.UUID       `db:"media_id" json:"mediaId"`
	AssetID             null_v4.Int     `db:"asset_id" json:"assetId"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	OriginalTitle       null_v4.String  `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Images              json.RawMessage `db:"images" json:"images"`
	ParentEpisodeID     null_v4.Int     `db:"parent_episode_id" json:"parentEpisodeId"`
	ParentStartsAt      sql.NullFloat64 `db:"parent_starts_at" json:"parentStartsAt"`
	ParentEndsAt        sql.NullFloat64 `db:"parent_ends_at" json:"parentEndsAt"`
	Label               string          `db:"label" json:"label"`
	TagIds              []int32         `db:"tag_ids" json:"tagIds"`
	DateUpdated         time.Time       `db:"date_updated" json:"dateUpdated"`
}

func (q *Queries) getShorts(ctx context.Context, ids []uuid.UUID) ([]getShortsRow, error) {
	rows, err := q.db.QueryContext(ctx, getShorts, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getShortsRow
	for rows.Next() {
		var i getShortsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.MediaID,
			&i.AssetID,
			&i.Title,
			&i.Description,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Images,
			&i.ParentEpisodeID,
			&i.ParentStartsAt,
			&i.ParentEndsAt,
			&i.Label,
			pq.Array(&i.TagIds),
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShortsByMediaItemID = `-- name: getShortsByMediaItemID :many
SELECT s.id,
       s.status,
       mi.id                                                AS media_id,
       mi.asset_id,
       mi.title,
       mi.description,
       mi.original_title,
       mi.original_description,
       mi.images,
       mi.parent_episode_id,
       mi.parent_starts_at,
       mi.parent_ends_at,
       mi.label,
       GREATEST(s.date_updated, mi.date_updated)::timestamp AS date_updated
FROM shorts s
         JOIN mediaitems_view mi ON mi.id = s.mediaitem_id
WHERE s.mediaitem_id = $1::uuid
`

type getShortsByMediaItemIDRow struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	Status              string          `db:"status" json:"status"`
	MediaID             uuid.UUID       `db:"media_id" json:"mediaId"`
	AssetID             null_v4.Int     `db:"asset_id" json:"assetId"`
	Title               json.RawMessage `db:"title" json:"title"`
	Description         json.RawMessage `db:"description" json:"description"`
	OriginalTitle       null_v4.String  `db:"original_title" json:"originalTitle"`
	OriginalDescription null_v4.String  `db:"original_description" json:"originalDescription"`
	Images              json.RawMessage `db:"images" json:"images"`
	ParentEpisodeID     null_v4.Int     `db:"parent_episode_id" json:"parentEpisodeId"`
	ParentStartsAt      sql.NullFloat64 `db:"parent_starts_at" json:"parentStartsAt"`
	ParentEndsAt        sql.NullFloat64 `db:"parent_ends_at" json:"parentEndsAt"`
	Label               string          `db:"label" json:"label"`
	DateUpdated         time.Time       `db:"date_updated" json:"dateUpdated"`
}

func (q *Queries) getShortsByMediaItemID(ctx context.Context, id uuid.UUID) ([]getShortsByMediaItemIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getShortsByMediaItemID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getShortsByMediaItemIDRow
	for rows.Next() {
		var i getShortsByMediaItemIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.MediaID,
			&i.AssetID,
			&i.Title,
			&i.Description,
			&i.OriginalTitle,
			&i.OriginalDescription,
			&i.Images,
			&i.ParentEpisodeID,
			&i.ParentStartsAt,
			&i.ParentEndsAt,
			&i.Label,
			&i.DateUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
