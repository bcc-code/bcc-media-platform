// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user-devices.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const deleteDevices = `-- name: DeleteDevices :exec
DELETE
FROM users.devices d
WHERE d.token = ANY ($1::varchar[])
`

func (q *Queries) DeleteDevices(ctx context.Context, tokens []string) error {
	_, err := q.db.ExecContext(ctx, deleteDevices, pq.Array(tokens))
	return err
}

const listDevicesInApplicationGroup = `-- name: ListDevicesInApplicationGroup :many
SELECT d.token,
       d.profile_id,
       d.updated_at,
       d.name,
       d.languages::varchar[] as languages,
       d.application_group_id,
       d.os,
       d.app_build_number
FROM users.devices d
WHERE d.application_group_id = $1::uuid
`

type ListDevicesInApplicationGroupRow struct {
	Token              string         `db:"token" json:"token"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	Languages          []string       `db:"languages" json:"languages"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppBuildNumber     int32          `db:"app_build_number" json:"appBuildNumber"`
}

func (q *Queries) ListDevicesInApplicationGroup(ctx context.Context, groupID uuid.UUID) ([]ListDevicesInApplicationGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, listDevicesInApplicationGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDevicesInApplicationGroupRow
	for rows.Next() {
		var i ListDevicesInApplicationGroupRow
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicesForProfiles = `-- name: getDevicesForProfiles :many
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages::varchar[] as languages, d.application_group_id, d.os, d.app_build_number
FROM users.devices d
WHERE d.profile_id = ANY ($1::uuid[])
  AND d.updated_at > (NOW() - interval '6 months')
ORDER BY updated_at DESC
`

type getDevicesForProfilesRow struct {
	Token              string         `db:"token" json:"token"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	Languages          []string       `db:"languages" json:"languages"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppBuildNumber     int32          `db:"app_build_number" json:"appBuildNumber"`
}

func (q *Queries) getDevicesForProfiles(ctx context.Context, dollar_1 []uuid.UUID) ([]getDevicesForProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getDevicesForProfiles, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getDevicesForProfilesRow
	for rows.Next() {
		var i getDevicesForProfilesRow
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevices = `-- name: listDevices :many
SELECT d.token, d.profile_id,
       d.updated_at, d.name,
       d.languages::varchar[] as languages, d.application_group_id,
       d.os, d.app_build_number
FROM users.devices d
WHERE d.updated_at > (NOW() - interval '6 months')
ORDER BY updated_at DESC
`

type listDevicesRow struct {
	Token              string         `db:"token" json:"token"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	Languages          []string       `db:"languages" json:"languages"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppBuildNumber     int32          `db:"app_build_number" json:"appBuildNumber"`
}

func (q *Queries) listDevices(ctx context.Context) ([]listDevicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listDevicesRow
	for rows.Next() {
		var i listDevicesRow
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevicesForRoles = `-- name: listDevicesForRoles :many
SELECT
    d.token,
    d.profile_id,
    d.updated_at,
    d.name,
    d.languages::varchar[] AS languages,
    d.application_group_id,
    d.os,
    d.app_build_number
FROM users.devices d
         LEFT JOIN users.profiles p ON d.profile_id = p.id
         LEFT JOIN users.users u ON p.user_id = u.id
WHERE
    d.application_group_id = $1::uuid
  AND (
    (u.roles && $2::varchar[] AND d.profile_id IS NOT NULL)
        OR ('public' = ANY($2::varchar[]) AND d.profile_id IS NULL)
    )
  AND d.updated_at > (NOW() - INTERVAL '6 months')
ORDER BY d.updated_at DESC
`

type listDevicesForRolesParams struct {
	Appgroupid uuid.UUID `db:"appgroupid" json:"appgroupid"`
	Roles      []string  `db:"roles" json:"roles"`
}

type listDevicesForRolesRow struct {
	Token              string         `db:"token" json:"token"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	Languages          []string       `db:"languages" json:"languages"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppBuildNumber     int32          `db:"app_build_number" json:"appBuildNumber"`
}

func (q *Queries) listDevicesForRoles(ctx context.Context, arg listDevicesForRolesParams) ([]listDevicesForRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDevicesForRoles, arg.Appgroupid, pq.Array(arg.Roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listDevicesForRolesRow
	for rows.Next() {
		var i listDevicesForRolesRow
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDeviceToken = `-- name: setDeviceToken :exec
INSERT INTO users.devices (token, languages, profile_id, updated_at, name, application_group_id, os, app_build_number)
VALUES ($1::varchar, $2::varchar[], $3, $4, $5, $6, $7, $8)
ON CONFLICT (token, application_group_id) DO UPDATE SET updated_at = EXCLUDED.updated_at,
                                              name       = EXCLUDED.name,
                                              languages  = EXCLUDED.languages,
                                              application_group_id = EXCLUDED.application_group_id,
                                              profile_id = EXCLUDED.profile_id,
                                              os = EXCLUDED.os,
                                              app_build_number = EXCLUDED.app_build_number
`

type setDeviceTokenParams struct {
	Token              string         `db:"token" json:"token"`
	Languages          []string       `db:"languages" json:"languages"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppVersion         int32          `db:"app_version" json:"appVersion"`
}

func (q *Queries) setDeviceToken(ctx context.Context, arg setDeviceTokenParams) error {
	_, err := q.db.ExecContext(ctx, setDeviceToken,
		arg.Token,
		pq.Array(arg.Languages),
		arg.ProfileID,
		arg.UpdatedAt,
		arg.Name,
		arg.ApplicationGroupID,
		arg.Os,
		arg.AppVersion,
	)
	return err
}
