// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user-devices.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	null_v4 "gopkg.in/guregu/null.v4"
)

const deleteDevices = `-- name: DeleteDevices :exec
DELETE
FROM users.devices d
WHERE d.token = ANY ($1::varchar[])
`

func (q *Queries) DeleteDevices(ctx context.Context, tokens []string) error {
	_, err := q.db.ExecContext(ctx, deleteDevices, pq.Array(tokens))
	return err
}

const getSegmentedDevicesForTarget = `-- name: GetSegmentedDevicesForTarget :many
WITH t as (SELECT
               int4range(application_minimum_build_number, application_maximum_build_number, '[]') AS build_range,
               int4range(inactive_days_min, inactive_days_max, '[]') as inactive_range,
               device_os, languages, (SELECT array_agg(usergroups_code) FROM targets_usergroups WHERE targets_id = $2) usergroups
           FROM targets t
           WHERE t.id = $2)
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages, d.id, d.application_group_id, d.os, d.app_build_number FROM users.devices d
                  CROSS JOIN t
                  LEFT JOIN users.profiles p ON d.profile_id = p.id
                  LEFT JOIN users.users u ON p.user_id = u.id
WHERE
    (
        (
            -- Filter by roles. If profile is not available, filter by public role
               u.roles && t.usergroups AND d.profile_id IS NOT NULL)
            OR ('public' = ANY(t.usergroups) AND d.profile_id IS NULL)
            OR t.usergroups IS NULL -- If no usergroups are specified, we send to everyone
        ) AND (
            -- Filter out stuff that has not been updated in the last 6 months
            d.updated_at > (NOW() - INTERVAL '6 months')

        -- OS filter. If no OS is specified, we don't filter
        AND (to_jsonb(d.os) <@ t.device_os OR jsonb_array_length(t.device_os) = 0)

        -- Build number filter. If the min and max are NULL then the filter == (-INF, +INF)
        AND (d.app_build_number <@ t.build_range OR t.build_range IS NULL)

        -- Inactive days. If the min and max are NULL then the filter == (-INF, +INF)
        AND (date_part('day', now() - d.updated_at)::int <@ t.inactive_range OR t.inactive_range IS NULL)

        -- Language filter. If languages are not specified, we don't filter
        AND (to_jsonb(d.languages) <@ t.languages OR jsonb_array_length(t.languages) = 0)

        -- Filter by application group, otherwise we sent all notifications to all apps
        AND d.application_group_id = $1
    )
`

type GetSegmentedDevicesForTargetParams struct {
	ApplicationgroupID uuid.UUID `db:"applicationgroup_id" json:"applicationgroupId"`
	TargetID           uuid.UUID `db:"target_id" json:"targetId"`
}

func (q *Queries) GetSegmentedDevicesForTarget(ctx context.Context, arg GetSegmentedDevicesForTargetParams) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, getSegmentedDevicesForTarget, arg.ApplicationgroupID, arg.TargetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ID,
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevicesInApplicationGroup = `-- name: ListDevicesInApplicationGroup :many
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages, d.id, d.application_group_id, d.os, d.app_build_number
FROM users.devices d
WHERE d.application_group_id = $1::uuid
`

func (q *Queries) ListDevicesInApplicationGroup(ctx context.Context, groupID uuid.UUID) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, listDevicesInApplicationGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ID,
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDevicesForProfiles = `-- name: getDevicesForProfiles :many
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages, d.id, d.application_group_id, d.os, d.app_build_number
FROM users.devices d
WHERE d.profile_id = ANY ($1::uuid[])
  AND d.updated_at > (NOW() - interval '6 months')
ORDER BY updated_at DESC
`

func (q *Queries) getDevicesForProfiles(ctx context.Context, dollar_1 []uuid.UUID) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, getDevicesForProfiles, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ID,
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevices = `-- name: listDevices :many
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages, d.id, d.application_group_id, d.os, d.app_build_number
FROM users.devices d
WHERE d.updated_at > (NOW() - interval '6 months')
ORDER BY updated_at DESC
`

func (q *Queries) listDevices(ctx context.Context) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, listDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ID,
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevicesForRoles = `-- name: listDevicesForRoles :many
SELECT d.token, d.profile_id, d.updated_at, d.name, d.languages, d.id, d.application_group_id, d.os, d.app_build_number
FROM users.devices d
         LEFT JOIN users.profiles p ON d.profile_id = p.id
         LEFT JOIN users.users u ON p.user_id = u.id
WHERE
    d.application_group_id = $1::uuid
  AND (
    (u.roles && $2::varchar[] AND d.profile_id IS NOT NULL)
        OR ('public' = ANY($2::varchar[]) AND d.profile_id IS NULL)
    )
  AND d.updated_at > (NOW() - INTERVAL '6 months')
ORDER BY d.updated_at DESC
`

type listDevicesForRolesParams struct {
	Appgroupid uuid.UUID `db:"appgroupid" json:"appgroupid"`
	Roles      []string  `db:"roles" json:"roles"`
}

func (q *Queries) listDevicesForRoles(ctx context.Context, arg listDevicesForRolesParams) ([]UsersDevice, error) {
	rows, err := q.db.QueryContext(ctx, listDevicesForRoles, arg.Appgroupid, pq.Array(arg.Roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersDevice
	for rows.Next() {
		var i UsersDevice
		if err := rows.Scan(
			&i.Token,
			&i.ProfileID,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Languages),
			&i.ID,
			&i.ApplicationGroupID,
			&i.Os,
			&i.AppBuildNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDeviceToken = `-- name: setDeviceToken :exec
INSERT INTO users.devices (token, languages, profile_id, updated_at, name, application_group_id, os, app_build_number)
VALUES ($1::varchar, $2::varchar[], $3, $4, $5, $6, $7, $8)
ON CONFLICT (token, application_group_id) DO UPDATE SET updated_at = EXCLUDED.updated_at,
                                              name       = EXCLUDED.name,
                                              languages  = EXCLUDED.languages,
                                              application_group_id = EXCLUDED.application_group_id,
                                              profile_id = EXCLUDED.profile_id,
                                              os = EXCLUDED.os,
                                              app_build_number = EXCLUDED.app_build_number
`

type setDeviceTokenParams struct {
	Token              string         `db:"token" json:"token"`
	Languages          []string       `db:"languages" json:"languages"`
	ProfileID          uuid.NullUUID  `db:"profile_id" json:"profileId"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updatedAt"`
	Name               string         `db:"name" json:"name"`
	ApplicationGroupID uuid.UUID      `db:"application_group_id" json:"applicationGroupId"`
	Os                 null_v4.String `db:"os" json:"os"`
	AppBuildNumber     int32          `db:"app_build_number" json:"appBuildNumber"`
}

func (q *Queries) setDeviceToken(ctx context.Context, arg setDeviceTokenParams) error {
	_, err := q.db.ExecContext(ctx, setDeviceToken,
		arg.Token,
		pq.Array(arg.Languages),
		arg.ProfileID,
		arg.UpdatedAt,
		arg.Name,
		arg.ApplicationGroupID,
		arg.Os,
		arg.AppBuildNumber,
	)
	return err
}
